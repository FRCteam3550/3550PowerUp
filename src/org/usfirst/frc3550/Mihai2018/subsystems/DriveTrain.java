// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3550.Mihai2018.subsystems;

import org.usfirst.frc3550.Mihai2018.RobotMap;
import org.usfirst.frc3550.Mihai2018.commands.ArcadeDrive;
import org.usfirst.frc3550.Mihai2018.commands.TankDriveWithJoystick;

import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS
	public static final double NORMALSPEED  = 0.95;  //drive for normal speed
	public static final double SLOWSPEED    = 0.50;  //drive motor slow speed
	public static final boolean SENSITIVITY = true; // drive motor sensibility

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController rearLeft = RobotMap.RearLeft;
    private final SpeedController rearRight = RobotMap.RearRight;
    private final SpeedController frontLeft = RobotMap.FrontLeft;
    private final SpeedController frontRight = RobotMap.FrontRight;
    private final DifferentialDrive robotDrive41 = RobotMap.m_drive;
   // private final AnalogGyro     gyro         = RobotMap.gyro;
  //  private final Encoder      encoder      =  RobotMap.deplacementleftRearMotor.getPIDSourceType();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    	

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    	
    	setDefaultCommand(new ArcadeDrive());
    	
    }
    
    public void stop() {
    	robotDrive41.tankDrive(0, 0);
    }
    
    public void tankDrive(double leftAxis, double rightAxis) {
    	robotDrive41.tankDrive(leftAxis, rightAxis);
    }
    
    public void arcadeDrive(Joystick stick) {
    	robotDrive41.arcadeDrive(-stick.getX(), stick.getY());
    }
    
    public double getGyroAngle(){
		return 0;
    	//return gyro.getAngle();
    }
    
    public void clearGyroAngle(){
    	 //gyro.reset();
    }
    
    public WPI_TalonSRX getLeftFrontMotor(){
		return null;
    	//return leftFrontMotor;
    }
    
    public WPI_TalonSRX getRightFrontMotor(){
		return null;
    	//return rightFrontMotor;
    }
    
    public WPI_TalonSRX getLeftRearMotor(){
		return null;
    	//return leftRearMotor;
    }
    
    public WPI_TalonSRX getRightRearMotor(){
		return null;
    	//return rightRearMotor;
    }
    
    public double getPositionLeftRearMotor(){
		return 0;
    	//return Robot.deplacement.getLeftRearMotor().getPosition(); 
    }
    
    public void clearLeftRearEncoder(){
    	//Robot.deplacement.getLeftRearMotor().setPosition(0);
    }
    
    public double getSpeedLeftRearMotor(){
		return 0;
    	//return Robot.deplacement.getLeftRearMotor().getSpeed();
    }
    /**
	 * stop method is used to stop the robot 
	 * 
	 * @param no input parameter
	 */
	public void stopBaseMobile() {
		robotDrive41.arcadeDrive(0, 0);
	}
	
	public void display(){
	 //SmartDashboard.putNumber("speedDeplacmentLeftFront", leftFrontMotor.get());
	 //SmartDashboard.putNumber("speedDeplacmentLeftRear",leftRearMotor.get());
	 //SmartDashboard.putNumber("speedDeplacmentRightFront", rightFrontMotor.get());
	 //SmartDashboard.putNumber("speedDeplacmentRightRear",rightRearMotor.get());
	 //SmartDashboard.putNumber("EncoderPosition", getPositionLeftRearMotor());
	}

	private void inverseMotors(boolean inverse) {
		frontLeft.setInverted(inverse);
		rearLeft.setInverted(inverse);
		frontRight.setInverted(inverse);
		rearRight.setInverted(inverse);
		//motorTest.setInverted(inverse);
	}
	
	/**
	 * driveStraight method is used in autonomous mode to let the robot goes straight
	 * 
	 * @param speed The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 */
	public void driveStraight(double speed) {
		inverseMotors(true);
		robotDrive41.arcadeDrive(speed, 0);
	}
	
	/**
	 * drive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void drive(double moveValue, double rotateValue) {
		inverseMotors(true);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue, NORMALSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDrive method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability.
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]
	 */
	public void inverseDrive(double moveValue, double rotateValue) {
		inverseMotors(false);
		robotDrive41.arcadeDrive(NORMALSPEED*moveValue,NORMALSPEED* -1 * rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot
	 * It provides the pilot with the ability to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */
	public void driveSlow(double moveValue, double rotateValue) {
		inverseMotors(true);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * inverseDriveSlow method provides a way to explicitly choose the joystick or gamePad axis in order to operate the robot. 
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param moveValue The speed that the robot should drive in the y direction in range [-1.0..1.0]*SLOWSPEED
	 * @param rotateValue The rate of rotation for the robot that is dependent of the translation. [-1.0..1.0]*SLOWSPEED
	 */	
	public void inverseDriveSlow(double moveValue, double rotateValue) {
		inverseMotors(false);
		robotDrive41.arcadeDrive(SLOWSPEED*moveValue, -1*SLOWSPEED*rotateValue, SENSITIVITY);
	}
	
	/**
	 * driveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void driveTank(double leftStick, double rightStick) {
		inverseMotors(true);
		robotDrive41.tankDrive(NORMALSPEED*leftStick, NORMALSPEED*rightStick, SENSITIVITY);
	}
	
	/**
	 * inversedriveTank method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]
	 */
	public void inverseTankDrive(double leftStick, double rightStick) {
		inverseMotors(false);
		robotDrive41.tankDrive(NORMALSPEED*rightStick, NORMALSPEED*leftStick, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void SlowTankDrive(double leftStick, double rightStick) {
		inverseMotors(true);
		robotDrive41.tankDrive(leftStick*SLOWSPEED, rightStick*SLOWSPEED, SENSITIVITY);
	}
	
	/**
	 * SlowTankDrive method provides a way to use gamePad axis in order to operate the robot on a tank drive
	 * This method was developed on Malcom's request
	 * It provides the pilot with the ability to switch front and rear of the robot for a better maneuverability
	 * Its purpose is to provide the pilot with the additional ability to to move swiftly in small areas
	 * 
	 * @param leftStick The value of the left stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 * @param rightStick The value of the right stick on the gamePadPilote in range [-1.0..1.0]*SLOWSPEED
	 */
	public void inverseSlowTankDrive(double leftStick, double rightStick) {
		inverseMotors(false);
		robotDrive41.tankDrive(rightStick*SLOWSPEED, leftStick*SLOWSPEED, SENSITIVITY);
	}
    
}

